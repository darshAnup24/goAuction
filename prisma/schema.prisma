generator client {
    provider = "prisma-client-js"
}

datasource db {
    provider = "mysql"
    url      = env("DATABASE_URL")
}

// Enums
enum UserRole {
    BUYER
    SELLER
    ADMIN
}

enum ListingStatus {
    UPCOMING
    LIVE
    ENDED
    SOLD
    UNSOLD
}

enum BidStatus {
    ACTIVE
    OUTBID
    WINNING
    WON
    LOST
}

enum PaymentStatus {
    PENDING
    COMPLETED
    FAILED
    REFUNDED
}

enum NotificationType {
    BID_PLACED
    BID_OUTBID
    AUCTION_WON
    AUCTION_LOST
    AUCTION_STARTING
    AUCTION_ENDING
    PAYMENT_RECEIVED
    PAYMENT_SENT
    NEW_MESSAGE
}

// User Model
model User {
    id                          String    @id @default(cuid())
    email                       String    @unique
    username                    String    @unique
    password                    String
    fullName                    String
    phone                       String?
    address                     String?   @db.Text
    avatar                      String?
    role                        UserRole  @default(BUYER)
    isVendor                    Boolean   @default(false)
    stripeAccountId             String?   @unique // Old field (keeping for compatibility)
    stripeConnectedAccountId    String?   @unique // Stripe Connect Account ID
    stripeOnboardingComplete    Boolean   @default(false) // Has completed Stripe onboarding
    stripeDetailsSubmitted      Boolean   @default(false) // Has submitted account details
    stripeChargesEnabled        Boolean   @default(false) // Can receive payments
    stripePayoutsEnabled        Boolean   @default(false) // Can receive payouts
    emailVerified               DateTime?
    ratingAsBuyer               Float     @default(0)
    ratingAsSeller              Float     @default(0)
    totalRatings                Int       @default(0)
    createdAt                   DateTime  @default(now())
    updatedAt                   DateTime  @updatedAt

    // Relations
    listings           Listing[]      @relation("SellerListings")
    bids               Bid[]
    paymentsAsBuyer    Payment[]      @relation("BuyerPayments")
    paymentsAsSeller   Payment[]      @relation("SellerPayments")
    notifications      Notification[]
    ratingsGiven       Rating[]       @relation("RatingsGiven")
    ratingsReceived    Rating[]       @relation("RatingsReceived")
    accounts           Account[]
    sessions           Session[]
    proxyBids          ProxyBid[]     @relation("UserProxyBids") // FEATURE 2: User's proxy bids

    @@index([email])
    @@index([username])
    @@index([isVendor])
}

// NextAuth Models
model Account {
    id                String  @id @default(cuid())
    userId            String
    type              String
    provider          String
    providerAccountId String
    refresh_token     String? @db.Text
    access_token      String? @db.Text
    expires_at        Int?
    token_type        String?
    scope             String?
    id_token          String? @db.Text
    session_state     String?

    user User @relation(fields: [userId], references: [id], onDelete: Cascade)

    @@unique([provider, providerAccountId])
    @@index([userId])
}

model Session {
    id           String   @id @default(cuid())
    sessionToken String   @unique
    userId       String
    expires      DateTime

    user User @relation(fields: [userId], references: [id], onDelete: Cascade)

    @@index([userId])
}

model VerificationToken {
    identifier String
    token      String   @unique
    expires    DateTime

    @@unique([identifier, token])
}

// Listing (Auction Item) Model
model Listing {
    id                           String        @id @default(cuid())
    title                        String
    description                  String        @db.Text
    images                       Json
    startingPrice                Float
    reservePrice                 Float?
    currentBid                   Float         @default(0)
    startTime                    DateTime
    endTime                      DateTime
    status                       ListingStatus @default(UPCOMING)
    category                     String
    type                         String        @default("AUCTION") // AUCTION or BUY_NOW
    sellerId                     String
    winnerId                     String?
    viewCount                    Int           @default(0)
    bidCount                     Int           @default(0)
    version                      Int           @default(0) // FEATURE 1: Optimistic locking version
    endingSoonNotificationSent   Boolean       @default(false)
    paymentRequired              Boolean       @default(false) // True when auction ends with winner
    paymentCompleted             Boolean       @default(false) // True when winner pays
    paymentDueDate               DateTime?     // Payment deadline
    createdAt                    DateTime      @default(now())
    updatedAt                    DateTime      @updatedAt

    // Relations
    seller   User      @relation("SellerListings", fields: [sellerId], references: [id], onDelete: Cascade)
    bids     Bid[]
    payments Payment[]
    proxyBids ProxyBid[] // FEATURE 2: Auto-bid proxy bids

    @@index([sellerId])
    @@index([status])
    @@index([category])
    @@index([endTime])
    @@index([winnerId])
    @@index([paymentRequired])
    @@index([paymentCompleted])
    @@index([currentBid])
    @@index([startTime])
    @@index([bidCount])
    @@index([createdAt])
    @@index([status, endTime])
    @@index([category, status])
    @@index([version]) // FEATURE 1: Index for version checks
}

// Bid Model
model Bid {
    id        String    @id @default(cuid())
    amount    Float
    bidderId  String
    listingId String
    status    BidStatus @default(ACTIVE)
    isProxy   Boolean   @default(false) // FEATURE 2: Indicates if bid was placed by proxy system
    createdAt DateTime  @default(now())

    // Relations
    bidder  User    @relation(fields: [bidderId], references: [id], onDelete: Cascade)
    listing Listing @relation(fields: [listingId], references: [id], onDelete: Cascade)

    @@index([bidderId])
    @@index([listingId])
    @@index([status])
    @@index([createdAt])
    @@index([isProxy]) // FEATURE 2: Index for proxy bid queries
}

// Payment Model
model Payment {
    id                    String        @id @default(cuid())
    stripePaymentId       String?       @unique // Stripe Payment Intent ID
    stripeCheckoutSession String?       @unique // Stripe Checkout Session ID
    amount                Float
    shippingCharge        Float         @default(1.00) // Shipping charge (default $1)
    totalAmount           Float         // amount + shippingCharge
    buyerId               String
    sellerId              String
    listingId             String
    status                PaymentStatus @default(PENDING)
    platformFee           Float         @default(0)
    sellerPayout          Float
    currency              String        @default("usd")
    paymentMethod         String?       // card, bank_transfer, test_payment, etc.
    isTestPayment         Boolean       @default(false) // True for test/demo payments
    receiptUrl            String?       // Stripe receipt URL
    refundReason          String?
    createdAt             DateTime      @default(now())
    updatedAt             DateTime      @updatedAt

    // Relations
    buyer   User    @relation("BuyerPayments", fields: [buyerId], references: [id])
    seller  User    @relation("SellerPayments", fields: [sellerId], references: [id])
    listing Listing @relation(fields: [listingId], references: [id])

    @@index([buyerId])
    @@index([sellerId])
    @@index([listingId])
    @@index([status])
    @@index([stripePaymentId])
}

// Notification Model
model Notification {
    id        String           @id @default(cuid())
    userId    String
    type      NotificationType
    message   String           @db.Text
    link      String?
    isRead    Boolean          @default(false)
    createdAt DateTime         @default(now())

    // Relations
    user User @relation(fields: [userId], references: [id], onDelete: Cascade)

    @@index([userId])
    @@index([isRead])
    @@index([createdAt])
}

// Rating Model
model Rating {
    id           String   @id @default(cuid())
    rating       Int
    review       String?  @db.Text
    fromUserId   String
    toUserId     String
    listingId    String?
    createdAt    DateTime @default(now())

    // Relations
    fromUser User @relation("RatingsGiven", fields: [fromUserId], references: [id], onDelete: Cascade)
    toUser   User @relation("RatingsReceived", fields: [toUserId], references: [id], onDelete: Cascade)

    @@unique([fromUserId, toUserId, listingId])
    @@index([toUserId])
    @@index([rating])
}

// ===================================
// FEATURE 2: Auto-Bid Proxy Model
// ===================================
// Stores user's automatic bidding preferences
model ProxyBid {
    id              String   @id @default(cuid())
    userId          String
    listingId       String
    maxAmount       Float    // Maximum amount user is willing to bid
    currentAmount   Float    @default(0) // Current proxy bid amount placed
    incrementAmount Float    @default(5.00) // Amount to increment each bid
    isActive        Boolean  @default(true) // Whether proxy bid is still active
    createdAt       DateTime @default(now())
    updatedAt       DateTime @updatedAt

    // Relations
    user    User    @relation("UserProxyBids", fields: [userId], references: [id], onDelete: Cascade)
    listing Listing @relation(fields: [listingId], references: [id], onDelete: Cascade)

    @@unique([userId, listingId]) // One proxy bid per user per listing
    @@index([listingId, isActive]) // Query active proxy bids for a listing
    @@index([userId, isActive]) // Query user's active proxy bids
}

// ===================================
// FEATURE 3: System Health Check Model
// ===================================
// Stores health check history for monitoring
model HealthCheck {
    id           String   @id @default(cuid())
    service      String   // 'database', 'stripe', 'cloudinary', 'email', 'socket'
    status       String   // 'healthy', 'degraded', 'down'
    responseTime Int      // Response time in milliseconds
    errorMessage String?  @db.Text
    metadata     Json?    // Additional diagnostic information
    checkedAt    DateTime @default(now())

    @@index([service, checkedAt])
    @@index([status, checkedAt])
}
